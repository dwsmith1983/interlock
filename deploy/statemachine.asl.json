{
  "Comment": "Interlock pipeline lifecycle: evaluation, trigger, retry, monitoring, cascade (52 states)",
  "StartAt": "InitDefaults",
  "States": {
    "InitDefaults": {
      "Type": "Pass",
      "Comment": "Merge default values for optional input fields. States.Runtime on missing JSONPath is uncatchable, so all optional fields must exist before any state references them.",
      "Parameters": {
        "result.$": "States.JsonMerge(States.StringToJson('{\"replay\":false,\"date\":\"\"}'), $, false)"
      },
      "OutputPath": "$.result",
      "Next": "CheckExclusion"
    },
    "CheckExclusion": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkExclusion",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.checkExclusion",
      "Next": "IsExcluded",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "IsExcluded": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.checkExclusion.result",
          "StringEquals": "proceed",
          "Next": "AcquireLock"
        }
      ],
      "Default": "End"
    },
    "AcquireLock": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "acquireLock",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.acquireLock",
      "Next": "IsLockAcquired",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "IsLockAcquired": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.acquireLock.result",
          "StringEquals": "proceed",
          "Next": "CheckRunLog"
        }
      ],
      "Default": "End"
    },
    "CheckRunLog": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkRunLog",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "replay.$": "$.replay"
        }
      },
      "ResultPath": "$.checkRunLog",
      "Next": "ShouldProceedAfterRunLog",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "ShouldProceedAfterRunLog": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.checkRunLog.result",
          "StringEquals": "proceed",
          "Next": "ResolvePipeline"
        }
      ],
      "Default": "ReleaseLock"
    },
    "ResolvePipeline": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "resolvePipeline",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "date.$": "$.date"
      },
      "ResultPath": "$.resolvePipeline",
      "Next": "IsResolved",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "IsResolved": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.resolvePipeline.result",
          "StringEquals": "proceed",
          "Next": "EvaluateTraits"
        }
      ],
      "Default": "LogResolveFailed"
    },
    "LogResolveFailed": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID": "",
          "message.$": "$.resolvePipeline.message",
          "failureCategory": "PERMANENT"
        }
      },
      "ResultPath": "$.logResolveFailed",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "EvaluateTraits": {
      "Type": "Map",
      "ItemsPath": "$.resolvePipeline.payload.traits",
      "MaxConcurrency": 0,
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "INLINE"
        },
        "StartAt": "EvaluateSingleTrait",
        "States": {
          "EvaluateSingleTrait": {
            "Type": "Task",
            "Resource": "${EvaluatorFunctionArn}",
            "End": true,
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.AWSLambdaException",
                  "Lambda.SdkClientException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 2,
                "MaxAttempts": 3,
                "BackoffRate": 2
              }
            ]
          }
        }
      },
      "ResultPath": "$.traitResults",
      "Next": "CheckEvaluationSLA",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "CheckEvaluationSLA": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkEvaluationSLA",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.evaluationSLA",
      "Next": "CheckValidationTimeout",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "CheckValidationTimeout": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkValidationTimeout",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.validationTimeout",
      "Next": "IsValidationTimedOut",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "IsValidationTimedOut": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.validationTimeout.payload.validationTimedOut",
          "BooleanEquals": true,
          "Next": "LogValidationTimeout"
        }
      ],
      "Default": "CheckReadiness"
    },
    "LogValidationTimeout": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message": "validation timed out",
          "failureCategory": "TIMEOUT"
        }
      },
      "ResultPath": "$.logRunFailed",
      "Next": "ShouldRetry",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "CheckReadiness": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkReadiness",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "traitResults.$": "$.traitResults"
        }
      },
      "ResultPath": "$.checkReadiness",
      "Next": "IsReady",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "IsReady": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.checkReadiness.result",
          "StringEquals": "proceed",
          "Next": "TriggerPipeline"
        },
        {
          "Variable": "$.checkReadiness.result",
          "StringEquals": "error",
          "Next": "LogEvaluatorError"
        }
      ],
      "Default": "CheckIfFirstEvalAttempt"
    },
    "CheckIfFirstEvalAttempt": {
      "Type": "Choice",
      "Comment": "Route to LogNotReady on first eval attempt, skip re-logging on retries.",
      "Choices": [
        {
          "Variable": "$.logNotReady",
          "IsPresent": true,
          "Next": "WaitForReadiness"
        }
      ],
      "Default": "LogNotReady"
    },
    "LogEvaluatorError": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message": "evaluator errors â€” check evaluator configuration",
          "failureCategory": "PERMANENT"
        }
      },
      "ResultPath": "$.logEvaluatorError",
      "Next": "AlertEvaluatorError",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "AlertEvaluatorError": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sns:publish",
      "Parameters": {
        "TopicArn": "${AlertTopicArn}",
        "Subject.$": "States.Format('[EVALUATOR ERROR] {} / {}', $.pipelineID, $.scheduleID)",
        "Message.$": "States.JsonToString($.checkReadiness.payload)"
      },
      "ResultPath": "$.alertEvaluatorResult",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.alertFailed",
          "Next": "ReleaseLock"
        }
      ]
    },
    "LogNotReady": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "PENDING",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message": "not ready - blocking traits"
        }
      },
      "ResultPath": "$.logNotReady",
      "Next": "WaitForReadiness",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "WaitForReadiness": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "EvaluateTraits"
    },
    "TriggerPipeline": {
      "Type": "Task",
      "Resource": "${TriggerFunctionArn}",
      "Parameters": {
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "trigger.$": "$.resolvePipeline.payload.trigger",
        "runID.$": "$.resolvePipeline.payload.runID"
      },
      "ResultPath": "$.triggerResult",
      "Next": "IsTriggerSuccessful",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.triggerError",
          "Next": "LogTriggerFailed"
        }
      ]
    },
    "IsTriggerSuccessful": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.triggerResult.status",
          "StringEquals": "running",
          "Next": "InitPollCounter"
        },
        {
          "Variable": "$.triggerResult.status",
          "StringEquals": "completed",
          "Next": "CheckCompletionSLA"
        }
      ],
      "Default": "LogTriggerFailed"
    },
    "LogTriggerFailed": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message": "trigger failed"
        }
      },
      "ResultPath": "$.logTriggerFailed",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "InitPollCounter": {
      "Type": "Pass",
      "Result": {
        "count": 0
      },
      "ResultPath": "$.pollCount",
      "Next": "WaitForRun"
    },
    "WaitForRun": {
      "Type": "Wait",
      "Seconds": 30,
      "Next": "PollRunStatus"
    },
    "PollRunStatus": {
      "Type": "Task",
      "Resource": "${RunCheckerFunctionArn}",
      "Parameters": {
        "pipelineID.$": "$.pipelineID",
        "runID.$": "$.resolvePipeline.payload.runID",
        "triggerType.$": "$.resolvePipeline.payload.trigger.type",
        "metadata.$": "$.triggerResult.metadata"
      },
      "ResultPath": "$.pollResult",
      "Next": "EvaluatePollResult",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "EvaluatePollResult": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.pollResult.state",
          "StringEquals": "succeeded",
          "Next": "CheckCompletionSLA"
        },
        {
          "Variable": "$.pollResult.state",
          "StringEquals": "failed",
          "Next": "LogRunFailed"
        }
      ],
      "Default": "IncrementPollCount"
    },
    "IncrementPollCount": {
      "Type": "Pass",
      "ResultPath": "$.pollCount",
      "Parameters": {
        "count.$": "States.MathAdd($.pollCount.count, 1)"
      },
      "Next": "CheckPollLimit",
      "Comment": "Increment poll counter"
    },
    "CheckPollLimit": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.pollCount.count",
          "NumericLessThan": 120,
          "Next": "WaitForRun"
        }
      ],
      "Default": "LogTimeout"
    },
    "CheckCompletionSLA": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkCompletionSLA",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.completionSLA",
      "Next": "LogCompleted",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "LogCompleted": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "COMPLETED",
          "runID.$": "$.resolvePipeline.payload.runID"
        }
      },
      "ResultPath": "$.logCompleted",
      "Next": "NotifyDownstream",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "NotifyDownstream": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "notifyDownstream",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.notifyDownstream",
      "Next": "ShouldMonitor",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.notifyError",
          "Next": "ShouldMonitor"
        }
      ]
    },
    "ShouldMonitor": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.resolvePipeline.payload.monitoring",
          "BooleanEquals": true,
          "Next": "InitMonitoringCounter"
        }
      ],
      "Default": "ReleaseLock"
    },
    "InitMonitoringCounter": {
      "Type": "Pass",
      "Parameters": {
        "count": 0,
        "monitoringStartedAt.$": "$$.State.EnteredTime"
      },
      "ResultPath": "$.monitoringState",
      "Next": "MonitoringWait"
    },
    "MonitoringWait": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "MonitoringEvaluate"
    },
    "MonitoringEvaluate": {
      "Type": "Map",
      "ItemsPath": "$.resolvePipeline.payload.traits",
      "MaxConcurrency": 0,
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "INLINE"
        },
        "StartAt": "MonitoringSingleTrait",
        "States": {
          "MonitoringSingleTrait": {
            "Type": "Task",
            "Resource": "${EvaluatorFunctionArn}",
            "End": true,
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.AWSLambdaException",
                  "Lambda.SdkClientException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 2,
                "MaxAttempts": 3,
                "BackoffRate": 2
              }
            ]
          }
        }
      },
      "ResultPath": "$.monitoringTraitResults",
      "Next": "MonitoringCheckDrift",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.monitoringError",
          "Next": "ReleaseLock"
        }
      ]
    },
    "MonitoringCheckDrift": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkDrift",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "traitResults.$": "$.monitoringTraitResults",
          "runID.$": "$.resolvePipeline.payload.runID"
        }
      },
      "ResultPath": "$.monitoringDrift",
      "Next": "IsDrifted",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.monitoringError",
          "Next": "ReleaseLock"
        }
      ]
    },
    "IsDrifted": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.monitoringDrift.payload.driftDetected",
          "BooleanEquals": true,
          "Next": "HandleLateArrival"
        }
      ],
      "Default": "IncrementMonitoringCount"
    },
    "HandleLateArrival": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "handleLateArrival",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "drifted.$": "$.monitoringDrift.payload.drifted",
          "runID.$": "$.resolvePipeline.payload.runID"
        }
      },
      "ResultPath": "$.handleLateArrival",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.lateArrivalError",
          "Next": "ReleaseLock"
        }
      ]
    },
    "IncrementMonitoringCount": {
      "Type": "Pass",
      "ResultPath": "$.monitoringState",
      "Parameters": {
        "count.$": "States.MathAdd($.monitoringState.count, 1)",
        "monitoringStartedAt.$": "$.monitoringState.monitoringStartedAt"
      },
      "Next": "CheckMonitoringExpired"
    },
    "CheckMonitoringExpired": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "checkMonitoringExpired",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "monitoringStartedAt.$": "$.monitoringState.monitoringStartedAt"
        }
      },
      "ResultPath": "$.monitoringExpiry",
      "Next": "IsMonitoringExpired",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.monitoringError",
          "Next": "ReleaseLock"
        }
      ]
    },
    "IsMonitoringExpired": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.monitoringExpiry.payload.expired",
          "BooleanEquals": true,
          "Next": "ReleaseLock"
        }
      ],
      "Default": "MonitoringWait"
    },
    "LogRunFailed": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message.$": "$.pollResult.message"
        }
      },
      "ResultPath": "$.logRunFailed",
      "Next": "ShouldRetry",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "ShouldRetry": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.logRunFailed.payload.retryable",
          "BooleanEquals": true,
          "Next": "RetryBackoffWait"
        }
      ],
      "Default": "ReleaseLock"
    },
    "RetryBackoffWait": {
      "Type": "Wait",
      "SecondsPath": "$.logRunFailed.payload.retryBackoffSeconds",
      "Next": "ReleaseLockForRetry"
    },
    "ReleaseLockForRetry": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "releaseLock",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.releaseLockForRetry",
      "Next": "AcquireLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.releaseLockRetryError",
          "Next": "AcquireLock"
        }
      ]
    },
    "LogTimeout": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "logResult",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID",
        "payload": {
          "status": "FAILED",
          "runID.$": "$.resolvePipeline.payload.runID",
          "message": "run polling timed out after 120 attempts"
        }
      },
      "ResultPath": "$.logTimeout",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "AlertError"
        }
      ]
    },
    "AlertError": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sns:publish",
      "Parameters": {
        "TopicArn": "${AlertTopicArn}",
        "Subject.$": "States.Format('[ERROR] {} / {}', $.pipelineID, $.scheduleID)",
        "Message.$": "States.JsonToString($.errorInfo)"
      },
      "ResultPath": "$.alertResult",
      "Next": "ReleaseLock",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.alertFailed",
          "Next": "ReleaseLock"
        }
      ]
    },
    "ReleaseLock": {
      "Type": "Task",
      "Resource": "${OrchestratorFunctionArn}",
      "Parameters": {
        "action": "releaseLock",
        "pipelineID.$": "$.pipelineID",
        "scheduleID.$": "$.scheduleID"
      },
      "ResultPath": "$.releaseLock",
      "Next": "End",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.releaseLockError",
          "Next": "AlertReleaseLockFailed"
        }
      ]
    },
    "AlertReleaseLockFailed": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sns:publish",
      "Parameters": {
        "TopicArn": "${AlertTopicArn}",
        "Subject.$": "States.Format('[LOCK ERROR] {} / {}', $.pipelineID, $.scheduleID)",
        "Message.$": "States.JsonToString($.releaseLockError)"
      },
      "ResultPath": "$.alertReleaseLockResult",
      "End": true,
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.alertReleaseLockFailed",
          "Next": "End"
        }
      ]
    },
    "End": {
      "Type": "Succeed"
    }
  }
}
